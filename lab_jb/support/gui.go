package main

import (
	"fyne.io/fyne"
	"fyne.io/fyne/app"
	"fyne.io/fyne/dialog"
	"fyne.io/fyne/widget"

	"github.com/alecthomas/kong"

	"github.com/herclab/de2gui/de2gui"

	"fmt"
	"io/ioutil"
	"log"
	"regexp"
	"strconv"
	"strings"
	"unsafe"
)

//#include "support.h"
import "C"

// Load a file generated by FormatASCIIHex(). This function also supports the
// following extra features:
//
// * Blank lines are ignored
// * '_' characters in lines are ignored (e.g. '1234_5678' and '12345678' are
//   equivalent)
// * Comments starting with '#' are ignored
//
// These features can come in really handy when constructing binary input
// files by hand.
func LoadASCIIHex(hex string) ([]uint32, error) {
	binary := make([]uint32, 0)

	// used to detect comments
	re, err := regexp.Compile(`[#].*$`)
	if err != nil {
		return binary, err
	}

	for _, line := range strings.Split(hex, "\n") {
		// eliminate '_' delimiters that are sometimes used
		line = strings.Replace(line, "_", "", -1)

		// eliminate comments
		line = re.ReplaceAllString(line, "")

		// and whitespace
		line = strings.TrimSpace(line)

		// ignore empty lines
		if len(line) == 0 {
			continue
		}

		if len(line) != 8 {
			return binary,
				fmt.Errorf("Line '%s' is not of length 8", line)
		}

		val, err := strconv.ParseUint(line, 16, 32)
		if err != nil {
			return binary, err
		}
		binary = append(binary, uint32(val))
	}

	return binary, nil
}

func loadRomDialog(simstate *C.simulation_state, rootWindow fyne.Window) {
	dialog.ShowFileOpen(func(uri fyne.URIReadCloser, e error) {
		if e != nil {
			dialog.ShowError(e, rootWindow)
			return
		}

		if uri == nil {
			// user canceled
			return
		}

		content, err := ioutil.ReadAll(uri)
		if err != nil {
			dialog.ShowError(err, rootWindow)
			return
		}
		text := string(content)

		rom, err := LoadASCIIHex(text)
		if err != nil {
			dialog.ShowError(err, rootWindow)
			return
		}

		romaddr := 0
		for (romaddr < 4096) && (romaddr < len(rom)) {
			C.write_rom(simstate, C.uint(romaddr), C.uint(rom[romaddr]))
			romaddr++
		}

		for romaddr < 4096 {
			C.write_rom(simstate, C.uint(romaddr), 0)
			romaddr++
		}

		C.reset(simstate)
	}, rootWindow)
}

var CLI struct {
	LoadROM string `type:"existingfile" help:"Automatically load the specified ROM file before launching the GUI"`
}

func main() {
	log.Print("initializing DE2-115 simulation...")

	var uistate *de2gui.UIState
	var simstate *C.simulation_state
	var reglabels []*widget.Label

	kong.Parse(&CLI)

	// make up some dummy argument for the Verilator simulation
	argc := C.int(1)
	argv := make([]*C.char, 1)
	argv[0] = C.CString("gui")
	s := C.initialize_simulation(argc, &(argv[0]))
	log.Print("Initialized Verilator simulation")

	simstate = s

	romaddr := 0
	for romaddr < 4096 {
		C.write_rom(s, C.uint(romaddr), 0)
		romaddr++
	}
	log.Print("Initialized ROM")

	// load ROM if applicable
	if CLI.LoadROM != "" {
		log.Printf("Loading ROM image from file '%s'\n", CLI.LoadROM)

		content, err := ioutil.ReadFile(CLI.LoadROM)
		if err != nil {
			panic(err)
		}

		text := string(content)

		rom, err := LoadASCIIHex(text)
		if err != nil {
			panic(err)
		}

		romaddr := 0
		for (romaddr < 4096) && (romaddr < len(rom)) {
			C.write_rom(simstate, C.uint(romaddr), C.uint(rom[romaddr]))
			romaddr++
		}

		for romaddr < 4096 {
			C.write_rom(simstate, C.uint(romaddr), 0)
			romaddr++
		}

	}

	C.reset(s)

	log.Print("Initializing GUI...")
	app := app.New()

	w := app.NewWindow("DE2-115")

	w.SetMainMenu(
		fyne.NewMainMenu(
			fyne.NewMenu("File",
				fyne.NewMenuItem("Load ROM", func() {
					loadRomDialog(simstate, w)
				}),
			),
		),
	)
	w.SetMaster()
	w.Resize(fyne.Size{1000, 600})

	// containers used for register "Table"
	reglabels = make([]*widget.Label, 32)
	regaddrbox := widget.NewVBox(
		widget.NewLabelWithStyle("Register", fyne.TextAlignTrailing, fyne.TextStyle{true, false, false}),
	)
	reglabelbox := widget.NewVBox(
		widget.NewLabelWithStyle("Value", fyne.TextAlignLeading, fyne.TextStyle{true, false, false}),
	)

	// hack to create a table
	//
	// Basted on Andrew's workaround here:
	// https://github.com/fyne-io/fyne/issues/157#issuecomment-597319590
	for i := 0; i < 32; i++ {
		reglabels[i] = widget.NewLabelWithStyle(
			fmt.Sprintf("0x%02x", C.read_reg(simstate, C.uint(i))),
			fyne.TextAlignLeading,
			fyne.TextStyle{false, false, true},
		)

		reglabelbox.Append(reglabels[i])
		regaddrbox.Append(
			widget.NewLabelWithStyle(
				fmt.Sprintf("0x%02x", i),
				fyne.TextAlignTrailing,
				fyne.TextStyle{false, false, true}),
		)
	}
	regsplit := widget.NewHSplitContainer(regaddrbox, reglabelbox)

	// label to store probe values in
	probelabel := widget.NewLabelWithStyle(
		"Any probes you have defined will appear here.",
		fyne.TextAlignLeading,
		fyne.TextStyle{false, false, true},
	)

	uistate = de2gui.NewUIState()

	uistate.OnKEY = func(s *de2gui.UIState) {
		log.Printf("Tick=%d KEY=0x%05x", s.Tick, s.KEY())
		C.write_io(simstate, C.IO_KEY, C.uint32_t(s.KEY()))
	}

	uistate.OnSW = func(s *de2gui.UIState) {
		log.Printf("Tick=%d SW=0x%05x", s.Tick, s.SW())
		C.write_io(simstate, C.IO_SW, C.uint32_t(s.SW()))
	}

	uistate.OnTick = func(s *de2gui.UIState, final bool) {

		C.write_io(simstate, C.IO_SW, C.uint32_t(s.SW()))
		C.write_io(simstate, C.IO_KEY, C.uint32_t(s.KEY()))

		C.delay_cycles(simstate, C.ulong(1))

		s.Tick = uint64(simstate.cycleno)

		if !final {
			return
		}

		for i := 0; i < 32; i++ {
			reglabels[i].SetText(fmt.Sprintf("0x%02x", C.read_reg(simstate, C.uint(i))))
		}

		s.SetHEX(7, uint8(C.read_io(simstate, C.IO_HEX0)))
		s.SetHEX(6, uint8(C.read_io(simstate, C.IO_HEX1)))
		s.SetHEX(5, uint8(C.read_io(simstate, C.IO_HEX2)))
		s.SetHEX(4, uint8(C.read_io(simstate, C.IO_HEX3)))
		s.SetHEX(3, uint8(C.read_io(simstate, C.IO_HEX4)))
		s.SetHEX(2, uint8(C.read_io(simstate, C.IO_HEX5)))
		s.SetHEX(1, uint8(C.read_io(simstate, C.IO_HEX6)))
		s.SetHEX(0, uint8(C.read_io(simstate, C.IO_HEX7)))

		s.SetLEDR(uint32(C.read_io(simstate, C.IO_LEDR)))
		s.SetLEDG(uint32(C.read_io(simstate, C.IO_LEDG)))

		Cprobetext := C.read_probes(simstate)
		defer C.free(unsafe.Pointer(Cprobetext))
		probelabel.SetText(C.GoString(Cprobetext))
	}

	uistate.OnReset = func(s *de2gui.UIState) {
		log.Printf("Resetting simulation... ")
		C.reset(simstate)

		s.SetHEX(7, uint8(C.read_io(simstate, C.IO_HEX0)))
		s.SetHEX(6, uint8(C.read_io(simstate, C.IO_HEX1)))
		s.SetHEX(5, uint8(C.read_io(simstate, C.IO_HEX2)))
		s.SetHEX(4, uint8(C.read_io(simstate, C.IO_HEX3)))
		s.SetHEX(3, uint8(C.read_io(simstate, C.IO_HEX4)))
		s.SetHEX(2, uint8(C.read_io(simstate, C.IO_HEX5)))
		s.SetHEX(1, uint8(C.read_io(simstate, C.IO_HEX6)))
		s.SetHEX(0, uint8(C.read_io(simstate, C.IO_HEX7)))

		s.SetLEDR(uint32(C.read_io(simstate, C.IO_LEDR)))
		s.SetLEDG(uint32(C.read_io(simstate, C.IO_LEDG)))

		s.ClearFutures()
		s.ClearKEY()
		s.ClearSW()
		s.Tick = uint64(simstate.cycleno)
	}

	// create the layout
	w.SetContent(
		widget.NewHSplitContainer(
			widget.NewVBox(
				uistate.FyneObject(),
				widget.NewLabel("Probes:"),
				probelabel,
			),
			widget.NewScrollContainer(regsplit),
		))

	log.Print("Application initialized, beginning event loop... ")
	w.ShowAndRun()

}
